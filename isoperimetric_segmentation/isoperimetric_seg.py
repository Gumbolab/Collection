# -*- coding: utf-8 -*-
"""Isoperimetric_seg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DQDhqJ5ZZ3GjSciObUo74w_iXk2hg4pU
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import scipy.sparse as sp
import bisect

def Conjugate_gradient_method(L, b):
          # Giải hệ Lx = b  bằng phương pháp Conjugate gradient
          # số bước lặp tối đa 10 lần
          n=len(b)
          x=np.zeros(n)
         # print("vector x",x)
          r=b-L.dot(x)# r is an vector
         # print("vector r",r)
          N=100
          p=r
          thres=1e-1
         # print("vector p",p)
          for i in range(1,N):
                Lp = L.dot(p)
                top = np.dot(r.T, r)
                bottom = np.dot(p.T,Lp)
               # print(bottom)
                alpha = top / bottom

                x = x + alpha * p
           
                r = r - alpha * Lp
                #print(type(r[0]))
                
                
                residual = np.linalg.norm(r)
                #print(residual)
                if all(t<thres for t in r):
                    print("phai i kg",i)
                    return x
                new_top = np.dot(r.T, r)
                beta = new_top/top
                p = r + beta * p
                
          return x
def removecol(L,j):
      # remove column thứ j ra khỏi ma trận thưa L
          if j < 0:
              j += L.shape[1]

          if j < 0 or j >= L.shape[1]:
              raise IndexError('column index out of bounds')

          rows = L.rows
          data = L.data
          for i in range(L.shape[0]):
              pos = bisect.bisect_left(rows[i], j)
              if pos == len(rows[i]):
                  continue
              elif rows[i][pos] == j:
                  rows[i].pop(pos)
                  data[i].pop(pos)
                  if pos == len(rows[i]):
                      continue
              for pos2 in range(pos,len(rows[i])):
                  rows[i][pos2] -= 1

          L._shape = (L._shape[0],L._shape[1]-1)

def delete_row_csr(mat, i):
    #remove dòng thứ j tra khỏi ma trận thưa mat
    if not isinstance(mat, sp.csr_matrix):
        raise ValueError("works only for CSR format -- use .tocsr() first")
    n = mat.indptr[i+1] - mat.indptr[i]
    if n > 0:
        mat.data[mat.indptr[i]:-n] = mat.data[mat.indptr[i+1]:]
        mat.data = mat.data[:-n]
        mat.indices[mat.indptr[i]:-n] = mat.indices[mat.indptr[i+1]:]
        mat.indices = mat.indices[:-n]
    mat.indptr[i:-1] = mat.indptr[i+1:]
    mat.indptr[i:] -= n
    mat.indptr = mat.indptr[:-1]
    mat._shape = (mat._shape[0]-1, mat._shape[1])


def create_L(grayImage):
    # hàm nhận vào một ma trận ảnh xám
    #tính các weight bằng công thức w(ij) = exp(-beta(Ii-Ij)^2)
    #trả về một ma trận thưa L
    n = len(grayImage)
    m = len(grayImage[0])
    beta=95
    matrix_node = np.array(grayImage,dtype=np.float64)
    #tính Ii-Ij trên hàng ngang ????
    horizontal_edge = matrix_node[:,:m-1]-matrix_node[:,1:m]
    horizontal_edge = np.exp(-beta*np.square(horizontal_edge))
    #tính Ii-Ij trên hàng dọc
    vertical_edge = matrix_node[:n-1,:]-matrix_node[1:n,:]
    vertical_edge = np.exp(-beta*np.square(vertical_edge))

    #tạo ma trận thưa L
    L = sp.dok_matrix((n*m,n*m),dtype=np.float64)
    #trên mỗi cạnh của các cạnh nằm ngang (hơn nhau một vị trí) thêm vào L cho vị trí của đỉnh v(xy), v(yx), v(xx) và v(yy)
    for i in range(len(horizontal_edge)):
        for j in range(len(horizontal_edge[0])):
            x = i*m+j
            y = x+1
            L[x,y] = -horizontal_edge[i][j]
            L[y,x] = -horizontal_edge[i][j]
            
            L[x,x] += horizontal_edge[i][j]
        
            L[y,y] += horizontal_edge[i][j]

    #trên mỗi cạnh của các cạnh nằm dọc (hơn nhau 1 hàng, => n vị trí) thêm vào L cho vị trí của đỉnh v(xy), v(yx), v(xx) và v(yy)
    for i in range(len(vertical_edge)):
        for j in range(len(vertical_edge[0])):
            x = i*m+j
            y = x+m
            L[x,y] = -vertical_edge[i][j]
            L[y,x] = -vertical_edge[i][j]
            
            L[x,x] += vertical_edge[i][j]
        
            L[y,y] += vertical_edge[i][j]
    return L

def create_d_and_g(L):
    # hàm tạo d và ground_node g
    # d là vector bậc của tất cả các node trong L
    # g là node có bậc lớn nhất
        
          g=0
          n=L.shape[0]
          d=[]
          ##tim node co bac lon nhat
          for i in range(n):
                d.append(L[i,i])
                if L[i,i]>L[g,g]:
                    g=i
          
          return d, g


def create_d0(d,g):
    #hàm tạo d0 bằng cách xóa đi element vị trí thứ g
    d0 = np.array(d)
    d0 = np.delete(d0,g)
    return d0

def create_L0(L,g):
    # hàm tạo L0 bằng cách xóa đi cột g hàng g trong L
    L0 = sp.lil_matrix(L)
    removecol(L0,g)
    
    L0 = sp.csr_matrix(L0)
    delete_row_csr(L0,g)

    return L0

def calculate_X(L0,d0,g):
    #tính X0, thêm xg = 0 vào vị trí g, trả về vector X 
    X = Conjugate_gradient_method(L0,d0)
    X = np.insert(X,g,1)  
    return X

###đọc file hình example.png
image = cv2.imread("info.png")
print(image.shape)
grayImage = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)/255
plt.imshow(grayImage,cmap='gray')

#tạo ma trận L, vector bậc d và vị trí ground node g

L = create_L(grayImage)
d,g = create_d_and_g(L)
#print(len(d))

#tạo L0 và d0 dùng để giải tìm X0,remove col and row co dinh bac cao nhat
d0 = create_d0(d,g)

L0 = create_L0(L,g)


#tìm X0, sau đó thêm xg = 0 vào vị trí của g, trả về X
X_cal= calculate_X(L0,d0,g)
#print(X)

#X1 = X.reshape(image.shape[0],image.shape[1])
#X_cal
"""
medi =np.median(X_cal)
print(medi)
x_cut=np.zeros(len(X))
for i in range(len(X)):
  if X[i]>medi:
      x_cut[i]=1
      """
x2=X_cal.reshape(grayImage.shape[0],grayImage.shape[1])


#ret1,thresh1 = cv2.threshold(X_scale, 50, 255, cv2.THRESH_BINARY)


plt.imshow(grayImage,cmap='gray')
plt.show()
plt.imshow(x2,cmap='gray')
plt.show()